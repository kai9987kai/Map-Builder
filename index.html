<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Creative Canvas</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: Arial, sans-serif;
    }
    
    .sidebar {
      width: 250px;
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    
    .sidebar h2 {
      text-align: center;
      margin-top: 0;
    }
    
    .tool-button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      background-color: #34495e;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    
    .tool-button.active {
      background-color: #1abc9c;
    }
    
    .tool-button:hover {
      background-color: #1abc9c;
    }
    
    .color-picker, .background-color-picker, .stroke-width-picker {
      margin: 10px 0;
    }
    
    .color-picker label, .background-color-picker label, .stroke-width-picker label {
      display: block;
      margin-bottom: 5px;
    }
    
    .label-input-container {
      margin: 10px 0;
    }
    
    .label-input-container label {
      display: block;
      margin-bottom: 5px;
    }
    
    .label-input-container input {
      width: 100%;
      padding: 5px;
      margin-bottom: 5px;
      box-sizing: border-box;
    }
    
    .label-input-container button {
      width: 100%;
      padding: 10px;
      background-color: #e74c3c;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    
    .label-input-container button:hover {
      background-color: #c0392b;
    }
    
    .emoji-picker {
      display: flex;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    
    .emoji-btn {
      font-size: 24px;
      padding: 5px;
      margin: 3px;
      cursor: pointer;
      border: none;
      background: none;
    }
    
    .emoji-btn:hover {
      background-color: #34495e;
      border-radius: 4px;
    }
    
    .grid-toggle {
      margin: 10px 0;
    }
    
    .grid-toggle input {
      margin-right: 5px;
    }
    
    .action-buttons {
      margin: 10px 0;
    }
    
    .action-buttons button {
      width: 48%;
      padding: 10px;
      margin: 1%;
      background-color: #16a085;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    
    .action-buttons button:hover {
      background-color: #1abc9c;
    }
    
    .layer-list {
      margin-top: 20px;
    }
    
    .layer-list h3 {
      margin-bottom: 10px;
    }
    
    .layer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #34495e;
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
    }
    
    .layer-controls button {
      background: none;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      margin-left: 5px;
      font-size: 16px;
    }
    
    .layer-controls button:hover {
      color: #1abc9c;
    }
    
    .canvas-container {
      flex-grow: 1;
      position: relative;
      background-color: #ffffff;
    }
    
    #mainCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    
    .tooltip {
      position: absolute;
      background-color: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      font-size: 14px;
    }
    
    .sparkles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 5;
    }
    
    .sparkle {
      position: absolute;
      width: 5px;
      height: 5px;
      background: yellow;
      border-radius: 50%;
      animation: sparkle 1s forwards;
    }
    
    @keyframes sparkle {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }
    
    /* Alignment Tools Styling */
    .alignment-tools {
      margin: 10px 0;
    }
    
    .alignment-tools button {
      width: 48%;
      padding: 10px;
      margin: 1%;
      background-color: #2980b9;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 14px;
    }
    
    .alignment-tools button:hover {
      background-color: #3498db;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>Tools</h2>
    <button id="freeDrawBtn" class="tool-button">✏️ Free Draw</button>
    <button id="contourBtn" class="tool-button">🖋️ Contour Maker</button>
    <button id="rectangleBtn" class="tool-button">▭ Rectangle</button>
    <button id="circleBtn" class="tool-button">⚪ Circle</button>
    <button id="lineBtn" class="tool-button">➖ Line</button>
    <button id="rulerBtn" class="tool-button">📏 Ruler</button>
    <button id="roadPenBtn" class="tool-button">🛣️ Road Pen</button>
    <button id="cornerPenBtn" class="tool-button">🔲 Corner Pen</button>
    <button id="moveBtn" class="tool-button">🚚 Move</button>
    <button id="selectBtn" class="tool-button">🔘 Select</button>
    <button id="resizeBtn" class="tool-button">↕️ Resize</button>
    <button id="rotateBtn" class="tool-button">🔄 Rotate</button>
    <!-- New Tools Added -->
    <button id="eraserBtn" class="tool-button">🧽 Eraser</button>
    <button id="textBtn" class="tool-button">🅰️ Text</button>
    
    <!-- Alignment Tools -->
    <div class="alignment-tools">
      <h3>Align Tools</h3>
      <button id="alignLeftBtn">⬅️ Align Left</button>
      <button id="alignCenterBtn">➡️ Align Center</button>
      <button id="alignRightBtn">⬆️ Align Right</button>
      <button id="alignTopBtn">🔼 Align Top</button>
      <button id="alignMiddleBtn">🔽 Align Middle</button>
      <button id="alignBottomBtn">🔻 Align Bottom</button>
    </div>
    
    <div class="color-picker">
      <label for="strokeColorPicker">Stroke Color:</label>
      <input type="color" id="strokeColorPicker" value="#000000">
    </div>
    <div class="color-picker">
      <label for="fillColorPicker">Fill Color:</label>
      <input type="color" id="fillColorPicker" value="#ffffff">
    </div>
    <div class="background-color-picker">
      <label for="backgroundColorPicker">Background Color:</label>
      <input type="color" id="backgroundColorPicker" value="#ffffff">
    </div>
    <div class="stroke-width-picker">
      <label for="strokeWidth">Stroke Width:</label>
      <input type="range" id="strokeWidth" min="1" max="10" value="2">
    </div>
    
    <div class="label-input-container">
      <label for="labelInput">Add Label:</label>
      <input type="text" id="labelInput" placeholder="Enter text">
      <label for="labelColorPicker">Label Color:</label>
      <input type="color" id="labelColorPicker" value="#000000">
      <button id="addLabelBtn">➕ Add Label</button>
      <div class="sparkles" id="sparklesContainer"></div>
    </div>
    
    <div class="emoji-picker">
      <!-- Updated Emojis to Construction and Road Signs -->
      <button class="emoji-btn" data-emoji="🚧">🚧</button> <!-- Construction Sign -->
      <button class="emoji-btn" data-emoji="🛣️">🛣️</button> <!-- Motorway -->
      <button class="emoji-btn" data-emoji="🅿️">🅿️</button> <!-- Parking Sign -->
      <button class="emoji-btn" data-emoji="🚦">🚦</button> <!-- Traffic Light -->
      <button class="emoji-btn" data-emoji="⛽">⛽</button> <!-- Fuel Pump -->
      <button class="emoji-btn" data-emoji="🚸">🚸</button> <!-- Children Crossing -->
      <button class="emoji-btn" data-emoji="🚍">🚍</button> <!-- Bus -->
      <button class="emoji-btn" data-emoji="🚗">🚗</button> <!-- Car -->
      <button class="emoji-btn" data-emoji="🛑">🛑</button> <!-- Stop Sign -->
      <button class="emoji-btn" data-emoji="🚨">🚨</button> <!-- Police Car Light -->
      <button class="emoji-btn" data-emoji="🚥">🚥</button> <!-- Horizontal Traffic Light -->
      <button class="emoji-btn" data-emoji="🛤️">🛤️</button> <!-- Railway Track -->
      <button class="emoji-btn" data-emoji="🚀">🚀</button> <!-- Rocket (as an example) -->
      <button class="emoji-btn" data-emoji="🛩️">🛩️</button> <!-- Small Airplane -->
      <!-- Add more construction and road-related emojis as needed -->
    </div>
    
    <div class="grid-toggle">
      <input type="checkbox" id="gridToggle">
      <label for="gridToggle">Toggle Grid</label>
    </div>
    
    <div class="action-buttons">
      <button id="undoBtn">↩️ Undo</button>
      <button id="redoBtn">↪️ Redo</button>
      <button id="clearBtn">🧹 Clear Canvas</button>
      <button id="exportBtn">📤 Export as PNG</button>
    </div>
    
    <div class="layer-list">
      <h3>Layers</h3>
      <div id="layerList">
        <!-- Layer items will be appended here -->
      </div>
    </div>
  </div>
  
  <div class="canvas-container">
    <canvas id="mainCanvas"></canvas>
    <div id="tooltip" class="tooltip"></div>
    <div class="sparkles" id="sparklesContainer"></div>
  </div>
  
  <script>
    class AdvancedDrawingTool {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.shapes = [];
        this.history = [];
        this.historyIndex = -1;
        this.currentTool = 'freeDraw';
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.currentShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.selectedShape = null;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.selectedHandle = null;
        this.labelColor = '#000000';
        this.shiftPressed = false;
        this.tooltip = document.getElementById('tooltip');
        this.sparklesContainer = document.getElementById('sparklesContainer');
        this.sparkleTimeout = null;
        this.gridEnabled = false; // New property for grid toggle
        
        // Setup canvas and initial state
        this.setupCanvas();
        this.saveState();
        
        // Initialize event listeners
        this.initializeListeners();
      }
      
      setupCanvas() {
        this.resizeCanvas();
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = document.getElementById('strokeColorPicker').value;
        this.ctx.fillStyle = document.getElementById('fillColorPicker').value;
        this.ctx.lineWidth = document.getElementById('strokeWidth').value;
        // Set initial background color
        this.canvas.style.backgroundColor = document.getElementById('backgroundColorPicker').value;
      }
      
      initializeListeners() {
        // Tool Buttons
        document.getElementById('freeDrawBtn').addEventListener('click', () => this.setTool('freeDraw'));
        document.getElementById('contourBtn').addEventListener('click', () => this.setTool('contour'));
        document.getElementById('rectangleBtn').addEventListener('click', () => this.setTool('rectangle'));
        document.getElementById('circleBtn').addEventListener('click', () => this.setTool('circle'));
        document.getElementById('lineBtn').addEventListener('click', () => this.setTool('line'));
        document.getElementById('rulerBtn').addEventListener('click', () => this.setTool('ruler'));
        document.getElementById('roadPenBtn').addEventListener('click', () => this.setTool('roadPen'));
        document.getElementById('cornerPenBtn').addEventListener('click', () => this.setTool('cornerPen'));
        document.getElementById('moveBtn').addEventListener('click', () => this.setTool('move'));
        document.getElementById('selectBtn').addEventListener('click', () => this.setTool('select'));
        document.getElementById('resizeBtn').addEventListener('click', () => this.setTool('resize'));
        document.getElementById('rotateBtn').addEventListener('click', () => this.setTool('rotate'));
        // New Tools Event Listeners
        document.getElementById('eraserBtn').addEventListener('click', () => this.setTool('eraser'));
        document.getElementById('textBtn').addEventListener('click', () => this.setTool('text'));
        
        // Alignment Tools
        document.getElementById('alignLeftBtn').addEventListener('click', () => this.alignShape('left'));
        document.getElementById('alignCenterBtn').addEventListener('click', () => this.alignShape('center'));
        document.getElementById('alignRightBtn').addEventListener('click', () => this.alignShape('right'));
        document.getElementById('alignTopBtn').addEventListener('click', () => this.alignShape('top'));
        document.getElementById('alignMiddleBtn').addEventListener('click', () => this.alignShape('middle'));
        document.getElementById('alignBottomBtn').addEventListener('click', () => this.alignShape('bottom'));
        
        // Color and Stroke Width
        document.getElementById('strokeColorPicker').addEventListener('change', (e) => {
          this.ctx.strokeStyle = e.target.value;
          if(this.selectedShape) {
            this.selectedShape.strokeColor = e.target.value;
            this.saveState();
            this.render();
          }
        });
        document.getElementById('fillColorPicker').addEventListener('change', (e) => {
          this.ctx.fillStyle = e.target.value;
          if(this.selectedShape && ['rectangle', 'circle', 'contour'].includes(this.selectedShape.type)) {
            this.selectedShape.fillColor = e.target.value;
            this.saveState();
            this.render();
          }
        });
        document.getElementById('backgroundColorPicker').addEventListener('change', (e) => {
          this.canvas.style.backgroundColor = e.target.value;
          this.saveState();
          this.render();
        });
        document.getElementById('strokeWidth').addEventListener('input', (e) => {
          this.ctx.lineWidth = e.target.value;
          if(this.selectedShape) {
            this.selectedShape.lineWidth = e.target.value;
            this.saveState();
            this.render();
          }
        });
        
        // Emoji Picker
        const emojiPicker = document.querySelector('.emoji-picker');
        emojiPicker.addEventListener('click', (e) => {
          if (e.target.classList.contains('emoji-btn')) {
            const emoji = e.target.getAttribute('data-emoji');
            this.selectEmoji(emoji);
          }
        });
        
        // Add Label
        document.getElementById('addLabelBtn').addEventListener('click', () => this.addLabel());
        
        // Label Color Picker
        document.getElementById('labelColorPicker').addEventListener('change', (e) => {
          this.labelColor = e.target.value;
        });
        
        // Canvas Mouse Events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseout', (e) => this.onMouseUp(e));
        
        // Action Buttons
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportCanvas());
        
        // Grid Toggle
        document.getElementById('gridToggle').addEventListener('change', (e) => {
          this.gridEnabled = e.target.checked;
          this.render();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Handle keyboard events for aspect ratio
        window.addEventListener('keydown', (e) => {
          if(e.key === 'Shift') {
            this.shiftPressed = true;
          }
        });
        window.addEventListener('keyup', (e) => {
          if(e.key === 'Shift') {
            this.shiftPressed = false;
          }
        });
        
        // Tooltip handling
        this.canvas.addEventListener('mousemove', (e) => this.handleTooltip(e));
        this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
        
        // Label typing for sparkles effect
        document.getElementById('labelInput').addEventListener('input', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('focus', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('blur', () => this.hideSparkles());
      }
      
      resizeCanvas() {
        const parentWidth = this.canvas.parentElement.clientWidth;
        const parentHeight = this.canvas.parentElement.clientHeight;
        
        if (parentWidth === 0 || parentHeight === 0) {
          console.warn('Parent element has zero width or height.');
          return;
        }
        
        // Save current content
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.drawImage(this.canvas, 0, 0);
      
        // Resize canvas
        this.canvas.width = parentWidth;
        this.canvas.height = parentHeight;
      
        // Restore content
        this.ctx.drawImage(tempCanvas, 0, 0);
        this.render();
      }
      
      setTool(tool) {
        this.currentTool = tool;
        this.selectedShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.selectedHandle = null;
        this.canvas.style.cursor = 'default';
        
        // Update active button styling
        document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${tool}Btn`)?.classList.add('active');
        
        // Reset handles and selection
        this.render();
      }
      
      alignShape(alignment) {
        if(!this.selectedShape) {
          alert('Please select a shape to align.');
          return;
        }
        
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        
        switch(alignment) {
          case 'left':
            this.selectedShape.x = 0;
            break;
          case 'center':
            this.selectedShape.x = (canvasWidth - this.getBoundingBox(this.selectedShape).width) / 2;
            break;
          case 'right':
            this.selectedShape.x = canvasWidth - this.getBoundingBox(this.selectedShape).width;
            break;
          case 'top':
            this.selectedShape.y = 0;
            break;
          case 'middle':
            this.selectedShape.y = (canvasHeight - this.getBoundingBox(this.selectedShape).height) / 2;
            break;
          case 'bottom':
            this.selectedShape.y = canvasHeight - this.getBoundingBox(this.selectedShape).height;
            break;
          default:
            break;
        }
        
        this.saveState();
        this.render();
      }
      
      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedShape = {
          type: 'emoji',
          emoji: emoji,
          x: 0,
          y: 0,
          size: 24,
          rotation: 0
        };
      }
      
      addLabel() {
        const labelText = document.getElementById('labelInput').value.trim();
        if(labelText) {
          const label = {
            type: 'label',
            text: labelText,
            x: 50, // Default position
            y: 50,
            color: this.labelColor,
            rotation: 0
          };
          this.shapes.push(label);
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
        }
      }
      
      onMouseDown(e) {
        const { offsetX, offsetY } = e;
        
        // Handle Tool Actions
        if(this.currentTool === 'move') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) {
            this.selectedShape = shape;
            this.isMoving = true;
            this.moveOffsetX = offsetX - shape.x;
            this.moveOffsetY = offsetY - shape.y;
            this.render();
            return;
          }
        }
        
        if(this.currentTool === 'select') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) {
            this.selectedShape = shape;
            this.render();
            return;
          } else {
            this.selectedShape = null;
            this.render();
          }
        }
        
        if(['freeDraw', 'contour', 'rectangle', 'circle', 'line', 'ruler', 'roadPen', 'cornerPen', 'emoji', 'eraser', 'text'].includes(this.currentTool)) {
          this.isDrawing = true;
          this.startX = offsetX;
          this.startY = offsetY;
          
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape = {
              type: this.currentTool,
              path: [{x: offsetX, y: offsetY}],
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'rectangle') {
            this.currentShape = {
              type: 'rectangle',
              x: offsetX,
              y: offsetY,
              width: 0,
              height: 0,
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'circle') {
            this.currentShape = {
              type: 'circle',
              x: offsetX,
              y: offsetY,
              radius: 0,
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'line') {
            this.currentShape = {
              type: 'line',
              startX: offsetX,
              startY: offsetY,
              endX: offsetX,
              endY: offsetY,
              strokeColor: document.getElementById('strokeColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'ruler') {
            this.currentShape = {
              type: 'ruler',
              startX: offsetX,
              startY: offsetY,
              endX: offsetX,
              endY: offsetY,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'roadPen') {
            this.currentShape = {
              type: 'road',
              x: offsetX,
              y: offsetY,
              width: 200, // Increased length
              height: 20,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; // Roads are placed instantly
            this.saveState();
            this.render();
          } else if(this.currentTool === 'cornerPen') {
            this.currentShape = {
              type: 'corner',
              x: offsetX,
              y: offsetY,
              width: 50,
              height: 50,
              radius: 25,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; // Corners are placed instantly
            this.saveState();
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape = {
              type: 'eraser',
              path: [{x: offsetX, y: offsetY}],
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'text') {
            // Initiate text input
            const text = prompt("Enter text:");
            if(text) {
              const textColor = document.getElementById('labelColorPicker').value;
              const newText = {
                type: 'label',
                text: text,
                x: offsetX,
                y: offsetY,
                color: textColor,
                rotation: 0
              };
              this.shapes.push(newText);
              this.saveState();
              this.render();
            }
            this.isDrawing = false;
          } else if(this.currentTool === 'emoji') {
            // Emoji placement handled on mouse up
          }
        }
      }
      
      onMouseMove(e) {
        const { offsetX, offsetY } = e;
        
        // Update tooltip position and content
        this.handleTooltip(e);
        
        if(this.isDrawing && this.currentShape) {
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'rectangle') {
            this.currentShape.width = offsetX - this.startX;
            this.currentShape.height = offsetY - this.startY;
            this.render();
          } else if(this.currentTool === 'circle') {
            const radius = Math.sqrt(Math.pow(offsetX - this.startX, 2) + Math.pow(offsetY - this.startY, 2));
            this.currentShape.radius = radius;
            this.render();
          } else if(this.currentTool === 'line') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'ruler') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'emoji') {
            // Emoji placement handled on mouse up
          }
        }
        
        if(this.isMoving && this.selectedShape) {
          if(this.selectedShape.type === 'label') {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          } else if(this.selectedShape.type === 'emoji') {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          } else {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          }
          this.render();
        }
        
        if(this.isResizing && this.selectedShape && this.selectedHandle) {
          this.resizeShape(offsetX, offsetY, this.shiftPressed);
          this.render();
        }
        
        if(this.isRotating && this.selectedShape) {
          this.rotateShape(offsetX, offsetY);
          this.render();
        }
      }
      
      onMouseUp(e) {
        if(this.isDrawing) {
          this.isDrawing = false;
          this.currentShape = null;
          this.saveState();
        }
        
        if(this.isMoving) {
          this.isMoving = false;
          this.saveState();
        }
        
        if(this.isResizing) {
          this.isResizing = false;
          this.selectedHandle = null;
          this.saveState();
        }
        
        if(this.isRotating) {
          this.isRotating = false;
          this.saveState();
        }
        
        // Handle Emoji Placement
        if(this.currentTool === 'emoji' && this.selectedShape) {
          this.selectedShape.x = e.offsetX;
          this.selectedShape.y = e.offsetY;
          this.shapes.push({...this.selectedShape});
          this.selectedShape = null;
          this.saveState();
          this.render();
          this.setTool('freeDraw');
        }
      }
      
      getShapeAtPosition(x, y) {
        for(let i = this.shapes.length -1; i >=0; i--){
          const shape = this.shapes[i];
          if(shape.type === 'emoji') {
            const size = shape.size;
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            const emojiHeight = shape.size;
            if (x >= shape.x - emojiWidth / 2 && x <= shape.x + emojiWidth / 2 &&
                y >= shape.y - emojiHeight && y <= shape.y) {
              return shape;
            }
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            const textHeight = 16; // Approximate height
            if (x >= shape.x && x <= shape.x + textWidth &&
                y >= shape.y && y <= shape.y + textHeight) {
              return shape;
            }
          } else if(shape.type === 'ruler') {
            // Simple hit detection for ruler
            const distance = this.pointToLineDistance(x, y, shape.startX, shape.startY, shape.endX, shape.endY);
            if(distance <= 5) return shape;
          } else if(shape.type === 'road' || shape.type === 'corner') {
            if(x >= shape.x && x <= shape.x + shape.width &&
               y >= shape.y && y <= shape.y + shape.height){
              return shape;
            }
          } else if(['freeDraw', 'contour', 'rectangle', 'circle', 'line'].includes(shape.type)) {
            // For simplicity, using bounding box
            const bbox = this.getBoundingBox(shape);
            if(x >= bbox.x && x <= bbox.x + bbox.width &&
               y >= bbox.y && y <= bbox.y + bbox.height){
              return shape;
            }
          }
        }
        return null;
      }
      
      pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if(len_sq !== 0) //in case of 0 length line
          param = dot / len_sq;
        
        let xx, yy;
        
        if(param < 0) {
          xx = x1;
          yy = y1;
        }
        else if(param > 1) {
          xx = x2;
          yy = y2;
        }
        else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      renderSelectionBox(shape) {
        if(!shape) return;
        
        // Calculate bounding box
        let bbox = this.getBoundingBox(shape);
        
        // Apply rotation if applicable
        if(shape.rotation) {
          const centerX = bbox.x + bbox.width / 2;
          const centerY = bbox.y + bbox.height / 2;
          this.ctx.save();
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        
        // Draw bounding box
        this.ctx.strokeStyle = '#1abc9c';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([5, 3]);
        this.ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
        this.ctx.setLineDash([]);
        
        // Draw resize handles
        const handleSize = 8;
        const handles = this.getHandles(bbox);
        handles.forEach(handle => {
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(handle.x, handle.y, handle.width, handle.height);
        });
        
        // Draw rotate handle
        const rotateHandle = {
          x: bbox.x + bbox.width / 2 - 4, // handleSize / 2
          y: bbox.y - 30 - 4,
          width: 8,
          height: 8
        };
        this.ctx.fillStyle = '#1abc9c';
        this.ctx.fillRect(rotateHandle.x, rotateHandle.y, rotateHandle.width, rotateHandle.height);
        
        if(shape.rotation) {
          this.ctx.restore();
        }
      }
      
      getBoundingBox(shape) {
        if(shape.type === 'circle') {
          return {
            x: shape.x - shape.radius,
            y: shape.y - shape.radius,
            width: shape.radius * 2,
            height: shape.radius * 2
          };
        } else if(['road', 'corner', 'rectangle', 'label', 'emoji', 'line', 'ruler', 'freeDraw', 'contour', 'eraser'].includes(shape.type)) {
          // For simplicity, use x, y, width, height
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            const emojiHeight = shape.size;
            return {
              x: shape.x - emojiWidth / 2,
              y: shape.y - emojiHeight,
              width: emojiWidth,
              height: emojiHeight
            };
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            const textHeight = 16; // Approximate
            return {
              x: shape.x,
              y: shape.y,
              width: textWidth,
              height: textHeight
            };
          } else if(shape.type === 'line') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else if(shape.type === 'ruler') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else if(shape.type === 'eraser') {
            const path = shape.path;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs) - shape.lineWidth;
            const minY = Math.min(...ys) - shape.lineWidth;
            const maxX = Math.max(...xs) + shape.lineWidth;
            const maxY = Math.max(...ys) + shape.lineWidth;
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else {
            return {
              x: shape.x,
              y: shape.y,
              width: shape.width,
              height: shape.height
            };
          }
        }
        return {x:0, y:0, width:0, height:0};
      }
      
      getHandles(bbox) {
        const size = 8;
        return [
          {x: bbox.x - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-right'},
          {x: bbox.x - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-right'},
          {x: bbox.x + bbox.width / 2 - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-mid'},
          {x: bbox.x + bbox.width / 2 - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-mid'},
          {x: bbox.x - size / 2, y: bbox.y + bbox.height / 2 - size / 2, width: size, height: size, position: 'mid-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y + bbox.height / 2 - size / 2, width: size, height: size, position: 'mid-right'},
        ];
      }
      
      getHandleAtPosition(x, y, bbox) {
        const handles = this.getHandles(bbox);
        for(let handle of handles){
          if(x >= handle.x && x <= handle.x + handle.width &&
             y >= handle.y && y <= handle.y + handle.height){
            return handle.position;
          }
        }
        
        // Check rotate handle
        const rotateHandle = {
          x: bbox.x + bbox.width / 2 - 4, // handleSize / 2
          y: bbox.y - 30 - 4,
          width: 8,
          height: 8
        };
        if(x >= rotateHandle.x && x <= rotateHandle.x + rotateHandle.width &&
           y >= rotateHandle.y && y <= rotateHandle.y + rotateHandle.height){
          return 'rotate';
        }
        
        return null;
      }
      
      resizeShape(x, y, keepAspectRatio) {
        if(!this.selectedShape || !this.selectedHandle) return;
        
        const bbox = this.getBoundingBox(this.selectedShape);
        let newWidth = bbox.width;
        let newHeight = bbox.height;
        let newX = bbox.x;
        let newY = bbox.y;
        
        switch(this.selectedHandle) {
          case 'top-left':
            newWidth = bbox.width + (bbox.x - x);
            newHeight = bbox.height + (bbox.y - y);
            newX = x;
            newY = y;
            break;
          case 'top-right':
            newWidth = x - bbox.x;
            newHeight = bbox.height + (bbox.y - y);
            newY = y;
            break;
          case 'bottom-left':
            newWidth = bbox.width + (bbox.x - x);
            newHeight = y - bbox.y;
            newX = x;
            break;
          case 'bottom-right':
            newWidth = x - bbox.x;
            newHeight = y - bbox.y;
            break;
          case 'top-mid':
            newHeight = bbox.height + (bbox.y - y);
            newY = y;
            break;
          case 'bottom-mid':
            newHeight = y - bbox.y;
            break;
          case 'mid-left':
            newWidth = bbox.width + (bbox.x - x);
            newX = x;
            break;
          case 'mid-right':
            newWidth = x - bbox.x;
            break;
          default:
            break;
        }
        
        if(keepAspectRatio) {
          const aspectRatio = bbox.width / bbox.height;
          if(newWidth / newHeight > aspectRatio) {
            newWidth = newHeight * aspectRatio;
          } else {
            newHeight = newWidth / aspectRatio;
          }
          // Adjust x and y based on handle
          switch(this.selectedHandle) {
            case 'top-left':
              newX = bbox.x + bbox.width - newWidth;
              newY = bbox.y + bbox.height - newHeight;
              break;
            case 'top-right':
              newY = bbox.y + bbox.height - newHeight;
              break;
            case 'bottom-left':
              newX = bbox.x + bbox.width - newWidth;
              break;
            // Other handles can be adjusted similarly if needed
          }
        }
        
        // Update shape based on type
        if(['rectangle', 'road', 'corner'].includes(this.selectedShape.type)) {
          this.selectedShape.x = newX;
          this.selectedShape.y = newY;
          this.selectedShape.width = newWidth;
          this.selectedShape.height = newHeight;
        } else if(this.selectedShape.type === 'circle') {
          this.selectedShape.radius = Math.min(newWidth, newHeight) / 2;
        } else if(this.selectedShape.type === 'line') {
          if(['top-left', 'mid-left'].includes(this.selectedHandle)) {
            this.selectedShape.startX = newX;
            this.selectedShape.startY = newY;
          } else {
            this.selectedShape.endX = x;
            this.selectedShape.endY = y;
          }
        } else if(this.selectedShape.type === 'contour' || this.selectedShape.type === 'freeDraw' || this.selectedShape.type === 'eraser') {
          // Handle path-based shapes if needed
        }
        // Add more shape types if needed
      }
      
      rotateShape(x, y) {
        if(!this.selectedShape) return;
        
        const bbox = this.getBoundingBox(this.selectedShape);
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        const radians = Math.atan2(y - centerY, x - centerX);
        this.selectedShape.rotation = radians;
      }
      
      moveShape(x, y) {
        if(!this.selectedShape) return;
        
        this.selectedShape.x = x - this.moveOffsetX;
        this.selectedShape.y = y - this.moveOffsetY;
      }
      
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid if enabled
        if(this.gridEnabled) {
          this.drawGrid();
        }
        
        this.shapes.forEach(shape => {
          this.drawShape(shape);
        });
        
        if(this.selectedShape && ['select', 'resize', 'rotate', 'move'].includes(this.currentTool)) {
          this.renderSelectionBox(this.selectedShape);
        }
      }
      
      drawGrid() {
        const gridSize = 50;
        this.ctx.save();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 0.5;
        
        for(let x = 0; x <= this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        
        for(let y = 0; y <= this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        
        this.ctx.restore();
      }
      
      drawShape(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const centerX = shape.type === 'circle' ? shape.x : shape.x + shape.width / 2;
          const centerY = shape.type === 'circle' ? shape.y : shape.y + shape.height / 2;
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        
        switch(shape.type) {
          case 'freeDraw':
          case 'contour':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i =1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.lineWidth = shape.lineWidth;
            if(shape.fillColor && shape.type === 'contour') {
              this.ctx.fillStyle = shape.fillColor;
              this.ctx.fill();
            }
            this.ctx.stroke();
            break;
          case 'rectangle':
            this.ctx.beginPath();
            this.ctx.rect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'circle':
            this.ctx.beginPath();
            this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'line':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'ruler':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.stroke();
            // Draw label
            const deltaX = shape.endX - shape.startX;
            const deltaY = shape.endY - shape.startY;
            const length = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY));
            const midX = (shape.startX + shape.endX) / 2;
            const midY = (shape.startY + shape.endY) / 2;
            this.ctx.fillStyle = '#FFD700';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${length} px`, midX, midY - 10);
            break;
          case 'road':
            this.ctx.save();
            this.ctx.translate(shape.x + shape.width / 2, shape.y + shape.height / 2);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-shape.x - shape.width / 2, -shape.y - shape.height / 2);
            this.ctx.fillStyle = '#555';
            this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            // Draw lane markings
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            const laneSpacing = shape.width / 4;
            for(let i = 1; i < 4; i++) {
              this.ctx.beginPath();
              this.ctx.moveTo(shape.x + laneSpacing * i, shape.y + shape.height / 4);
              this.ctx.lineTo(shape.x + laneSpacing * i, shape.y + (3 * shape.height) / 4);
              this.ctx.stroke();
            }
            this.ctx.restore();
            break;
          case 'corner':
            this.ctx.save();
            this.ctx.translate(shape.x + shape.width / 2, shape.y + shape.height / 2);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-shape.x - shape.width / 2, -shape.y - shape.height / 2);
            this.ctx.fillStyle = '#555';
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(shape.x + shape.radius, shape.y);
            this.ctx.lineTo(shape.x + shape.width - shape.radius, shape.y);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y, shape.x + shape.width, shape.y + shape.radius);
            this.ctx.lineTo(shape.x + shape.width, shape.y + shape.height - shape.radius);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y + shape.height, shape.x + shape.width - shape.radius, shape.y + shape.height);
            this.ctx.lineTo(shape.x + shape.radius, shape.y + shape.height);
            this.ctx.quadraticCurveTo(shape.x, shape.y + shape.height, shape.x, shape.y + shape.height - shape.radius);
            this.ctx.lineTo(shape.x, shape.y + shape.radius);
            this.ctx.quadraticCurveTo(shape.x, shape.y, shape.x + shape.radius, shape.y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.restore();
            break;
          case 'emoji':
            this.ctx.font = `${shape.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.emoji, shape.x, shape.y);
            break;
          case 'label':
            this.ctx.font = "16px Arial";
            this.ctx.fillStyle = shape.color || '#000';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.text, shape.x, shape.y);
            break;
          case 'eraser':
            // Eraser acts like freeDraw but clears
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i =1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = shape.lineWidth * 5; // Eraser is larger
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.stroke();
            this.ctx.globalCompositeOperation = 'source-over';
            break;
          default:
            break;
        }
        
        this.ctx.restore();
      }
      
      handleTooltip(e) {
        const { offsetX, offsetY } = e;
        let tooltipText = '';
        const shape = this.getShapeAtPosition(offsetX, offsetY);
        if(shape) {
          tooltipText = shape.type.charAt(0).toUpperCase() + shape.type.slice(1);
          this.showTooltip(tooltipText, e.clientX, e.clientY);
        } else {
          this.hideTooltip();
        }
      }
      
      showTooltip(text, x, y) {
        this.tooltip.textContent = text;
        this.tooltip.style.left = `${x + 10}px`;
        this.tooltip.style.top = `${y + 10}px`;
        this.tooltip.style.opacity = 1;
      }
      
      hideTooltip() {
        this.tooltip.style.opacity = 0;
      }
      
      showSparkles() {
        const sparkleCount = 20;
        for(let i = 0; i < sparkleCount; i++) {
          const sparkle = document.createElement('div');
          sparkle.classList.add('sparkle');
          sparkle.style.left = `${Math.random() * this.sparklesContainer.clientWidth}px`;
          sparkle.style.top = `${Math.random() * this.sparklesContainer.clientHeight}px`;
          sparkle.style.opacity = Math.random();
          this.sparklesContainer.appendChild(sparkle);
          sparkle.addEventListener('animationend', () => {
            sparkle.remove();
          });
        }
      }
      
      hideSparkles() {
        this.sparklesContainer.innerHTML = '';
      }
      
      restoreLastState() {
        if (this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].shapes;
          this.shapes = JSON.parse(JSON.stringify(lastState));
          this.render();
        }
      }
      
      saveState() {
        if (this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex + 1);
        }
        const shapesCopy = JSON.parse(JSON.stringify(this.shapes));
        this.history.push({ shapes: shapesCopy });
        this.historyIndex++;
        this.updateLayerList();
      }
      
      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.restoreLastState();
        }
      }
      
      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.restoreLastState();
        }
      }
      
      clearCanvas() {
        this.shapes = [];
        this.saveState();
        this.render();
      }
      
      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }
      
      // Layer Management
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';
        
        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.innerHTML = `<span>Layer ${index + 1}</span>`;
          
          const controls = document.createElement('div');
          controls.classList.add('layer-controls');
          
          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = '👁️';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => {
            this.historyIndex = index;
            this.restoreLastState();
          });
          
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '❌';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if (this.historyIndex >= this.history.length) {
              this.historyIndex = this.history.length - 1;
            }
            this.restoreLastState();
            this.updateLayerList();
          });
          
          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }
      
      // Emoji and Label Handling
      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedShape = {
          type: 'emoji',
          emoji: emoji,
          x: 0,
          y: 0,
          size: 24,
          rotation: 0
        };
      }
      
      addLabel() {
        const labelText = document.getElementById('labelInput').value.trim();
        if(labelText) {
          const label = {
            type: 'label',
            text: labelText,
            x: 50, // Default position
            y: 50,
            color: this.labelColor,
            rotation: 0
          };
          this.shapes.push(label);
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
        }
      }
      
      onMouseDown(e) {
        const { offsetX, offsetY } = e;
        
        // Check if click is on a handle
        if(this.selectedShape && ['resize', 'rotate'].includes(this.currentTool)) {
          const bbox = this.getBoundingBox(this.selectedShape);
          const handle = this.getHandleAtPosition(offsetX, offsetY, bbox);
          if(handle) {
            if(handle === 'rotate') {
              this.isRotating = true;
            } else {
              this.isResizing = true;
              this.selectedHandle = handle;
            }
            return;
          }
        }
        
        // Handle Tool Actions
        if(this.currentTool === 'move') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) {
            this.selectedShape = shape;
            this.isMoving = true;
            this.moveOffsetX = offsetX - shape.x;
            this.moveOffsetY = offsetY - shape.y;
            this.render();
            return;
          }
        }
        
        if(this.currentTool === 'select') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) {
            this.selectedShape = shape;
            this.render();
            return;
          } else {
            this.selectedShape = null;
            this.render();
          }
        }
        
        if(['freeDraw', 'contour', 'rectangle', 'circle', 'line', 'ruler', 'roadPen', 'cornerPen', 'emoji', 'eraser', 'text'].includes(this.currentTool)) {
          this.isDrawing = true;
          this.startX = offsetX;
          this.startY = offsetY;
          
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape = {
              type: this.currentTool,
              path: [{x: offsetX, y: offsetY}],
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'rectangle') {
            this.currentShape = {
              type: 'rectangle',
              x: offsetX,
              y: offsetY,
              width: 0,
              height: 0,
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'circle') {
            this.currentShape = {
              type: 'circle',
              x: offsetX,
              y: offsetY,
              radius: 0,
              strokeColor: document.getElementById('strokeColorPicker').value,
              fillColor: document.getElementById('fillColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'line') {
            this.currentShape = {
              type: 'line',
              startX: offsetX,
              startY: offsetY,
              endX: offsetX,
              endY: offsetY,
              strokeColor: document.getElementById('strokeColorPicker').value,
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'ruler') {
            this.currentShape = {
              type: 'ruler',
              startX: offsetX,
              startY: offsetY,
              endX: offsetX,
              endY: offsetY,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'roadPen') {
            this.currentShape = {
              type: 'road',
              x: offsetX,
              y: offsetY,
              width: 200, // Increased length
              height: 20,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; // Roads are placed instantly
            this.saveState();
            this.render();
          } else if(this.currentTool === 'cornerPen') {
            this.currentShape = {
              type: 'corner',
              x: offsetX,
              y: offsetY,
              width: 50,
              height: 50,
              radius: 25,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; // Corners are placed instantly
            this.saveState();
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape = {
              type: 'eraser',
              path: [{x: offsetX, y: offsetY}],
              lineWidth: document.getElementById('strokeWidth').value,
              rotation: 0
            };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'text') {
            // Initiate text input
            const text = prompt("Enter text:");
            if(text) {
              const textColor = document.getElementById('labelColorPicker').value;
              const newText = {
                type: 'label',
                text: text,
                x: offsetX,
                y: offsetY,
                color: textColor,
                rotation: 0
              };
              this.shapes.push(newText);
              this.saveState();
              this.render();
            }
            this.isDrawing = false;
          } else if(this.currentTool === 'emoji') {
            // Emoji placement handled on mouse up
          }
        }
      }
      
      onMouseMove(e) {
        const { offsetX, offsetY } = e;
        
        // Update tooltip position and content
        this.handleTooltip(e);
        
        if(this.isDrawing && this.currentShape) {
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'rectangle') {
            this.currentShape.width = offsetX - this.startX;
            this.currentShape.height = offsetY - this.startY;
            this.render();
          } else if(this.currentTool === 'circle') {
            const radius = Math.sqrt(Math.pow(offsetX - this.startX, 2) + Math.pow(offsetY - this.startY, 2));
            this.currentShape.radius = radius;
            this.render();
          } else if(this.currentTool === 'line') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'ruler') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'emoji') {
            // Emoji placement handled on mouse up
          }
        }
        
        if(this.isMoving && this.selectedShape) {
          if(this.selectedShape.type === 'label') {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          } else if(this.selectedShape.type === 'emoji') {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          } else {
            this.selectedShape.x = offsetX - this.moveOffsetX;
            this.selectedShape.y = offsetY - this.moveOffsetY;
          }
          this.render();
        }
        
        if(this.isResizing && this.selectedShape && this.selectedHandle) {
          this.resizeShape(offsetX, offsetY, this.shiftPressed);
          this.render();
        }
        
        if(this.isRotating && this.selectedShape) {
          this.rotateShape(offsetX, offsetY);
          this.render();
        }
      }
      
      onMouseUp(e) {
        if(this.isDrawing) {
          this.isDrawing = false;
          this.currentShape = null;
          this.saveState();
        }
        
        if(this.isMoving) {
          this.isMoving = false;
          this.saveState();
        }
        
        if(this.isResizing) {
          this.isResizing = false;
          this.selectedHandle = null;
          this.saveState();
        }
        
        if(this.isRotating) {
          this.isRotating = false;
          this.saveState();
        }
        
        // Handle Emoji Placement
        if(this.currentTool === 'emoji' && this.selectedShape) {
          this.selectedShape.x = e.offsetX;
          this.selectedShape.y = e.offsetY;
          this.shapes.push({...this.selectedShape});
          this.selectedShape = null;
          this.saveState();
          this.render();
          this.setTool('freeDraw');
        }
      }
      
      getShapeAtPosition(x, y) {
        for(let i = this.shapes.length -1; i >=0; i--){
          const shape = this.shapes[i];
          if(shape.type === 'emoji') {
            const size = shape.size;
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            const emojiHeight = shape.size;
            if (x >= shape.x - emojiWidth / 2 && x <= shape.x + emojiWidth / 2 &&
                y >= shape.y - emojiHeight && y <= shape.y) {
              return shape;
            }
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            const textHeight = 16; // Approximate height
            if (x >= shape.x && x <= shape.x + textWidth &&
                y >= shape.y && y <= shape.y + textHeight) {
              return shape;
            }
          } else if(shape.type === 'ruler') {
            // Simple hit detection for ruler
            const distance = this.pointToLineDistance(x, y, shape.startX, shape.startY, shape.endX, shape.endY);
            if(distance <= 5) return shape;
          } else if(shape.type === 'road' || shape.type === 'corner') {
            if(x >= shape.x && x <= shape.x + shape.width &&
               y >= shape.y && y <= shape.y + shape.height){
              return shape;
            }
          } else if(['freeDraw', 'contour', 'rectangle', 'circle', 'line'].includes(shape.type)) {
            // For simplicity, using bounding box
            const bbox = this.getBoundingBox(shape);
            if(x >= bbox.x && x <= bbox.x + bbox.width &&
               y >= bbox.y && y <= bbox.y + bbox.height){
              return shape;
            }
          }
        }
        return null;
      }
      
      pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1;
        const B = py - y1;
        const C = x2 - x1;
        const D = y2 - y1;
        
        const dot = A * C + B * D;
        const len_sq = C * C + D * D;
        let param = -1;
        if(len_sq !== 0) //in case of 0 length line
          param = dot / len_sq;
        
        let xx, yy;
        
        if(param < 0) {
          xx = x1;
          yy = y1;
        }
        else if(param > 1) {
          xx = x2;
          yy = y2;
        }
        else {
          xx = x1 + param * C;
          yy = y1 + param * D;
        }
        
        const dx = px - xx;
        const dy = py - yy;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      renderSelectionBox(shape) {
        if(!shape) return;
        
        // Calculate bounding box
        let bbox = this.getBoundingBox(shape);
        
        // Apply rotation if applicable
        if(shape.rotation) {
          const centerX = bbox.x + bbox.width / 2;
          const centerY = bbox.y + bbox.height / 2;
          this.ctx.save();
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        
        // Draw bounding box
        this.ctx.strokeStyle = '#1abc9c';
        this.ctx.lineWidth = 1;
        this.ctx.setLineDash([5, 3]);
        this.ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
        this.ctx.setLineDash([]);
        
        // Draw resize handles
        const handleSize = 8;
        const handles = this.getHandles(bbox);
        handles.forEach(handle => {
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(handle.x, handle.y, handle.width, handle.height);
        });
        
        // Draw rotate handle
        const rotateHandle = {
          x: bbox.x + bbox.width / 2 - 4, // handleSize / 2
          y: bbox.y - 30 - 4,
          width: 8,
          height: 8
        };
        this.ctx.fillStyle = '#1abc9c';
        this.ctx.fillRect(rotateHandle.x, rotateHandle.y, rotateHandle.width, rotateHandle.height);
        
        if(shape.rotation) {
          this.ctx.restore();
        }
      }
      
      getBoundingBox(shape) {
        if(shape.type === 'circle') {
          return {
            x: shape.x - shape.radius,
            y: shape.y - shape.radius,
            width: shape.radius * 2,
            height: shape.radius * 2
          };
        } else if(['road', 'corner', 'rectangle', 'label', 'emoji', 'line', 'ruler', 'freeDraw', 'contour', 'eraser'].includes(shape.type)) {
          // For simplicity, use x, y, width, height
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            const emojiHeight = shape.size;
            return {
              x: shape.x - emojiWidth / 2,
              y: shape.y - emojiHeight,
              width: emojiWidth,
              height: emojiHeight
            };
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            const textHeight = 16; // Approximate
            return {
              x: shape.x,
              y: shape.y,
              width: textWidth,
              height: textHeight
            };
          } else if(shape.type === 'line') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else if(shape.type === 'ruler') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else if(shape.type === 'eraser') {
            const path = shape.path;
            const xs = path.map(p => p.x);
            const ys = path.map(p => p.y);
            const minX = Math.min(...xs) - shape.lineWidth;
            const minY = Math.min(...ys) - shape.lineWidth;
            const maxX = Math.max(...xs) + shape.lineWidth;
            const maxY = Math.max(...ys) + shape.lineWidth;
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else {
            return {
              x: shape.x,
              y: shape.y,
              width: shape.width,
              height: shape.height
            };
          }
        }
        return {x:0, y:0, width:0, height:0};
      }
      
      getHandles(bbox) {
        const size = 8;
        return [
          {x: bbox.x - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-right'},
          {x: bbox.x - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-right'},
          {x: bbox.x + bbox.width / 2 - size / 2, y: bbox.y - size / 2, width: size, height: size, position: 'top-mid'},
          {x: bbox.x + bbox.width / 2 - size / 2, y: bbox.y + bbox.height - size / 2, width: size, height: size, position: 'bottom-mid'},
          {x: bbox.x - size / 2, y: bbox.y + bbox.height / 2 - size / 2, width: size, height: size, position: 'mid-left'},
          {x: bbox.x + bbox.width - size / 2, y: bbox.y + bbox.height / 2 - size / 2, width: size, height: size, position: 'mid-right'},
        ];
      }
      
      getHandleAtPosition(x, y, bbox) {
        const handles = this.getHandles(bbox);
        for(let handle of handles){
          if(x >= handle.x && x <= handle.x + handle.width &&
             y >= handle.y && y <= handle.y + handle.height){
            return handle.position;
          }
        }
        
        // Check rotate handle
        const rotateHandle = {
          x: bbox.x + bbox.width / 2 - 4, // handleSize / 2
          y: bbox.y - 30 - 4,
          width: 8,
          height: 8
        };
        if(x >= rotateHandle.x && x <= rotateHandle.x + rotateHandle.width &&
           y >= rotateHandle.y && y <= rotateHandle.y + rotateHandle.height){
          return 'rotate';
        }
        
        return null;
      }
      
      resizeShape(x, y, keepAspectRatio) {
        if(!this.selectedShape || !this.selectedHandle) return;
        
        const bbox = this.getBoundingBox(this.selectedShape);
        let newWidth = bbox.width;
        let newHeight = bbox.height;
        let newX = bbox.x;
        let newY = bbox.y;
        
        switch(this.selectedHandle) {
          case 'top-left':
            newWidth = bbox.width + (bbox.x - x);
            newHeight = bbox.height + (bbox.y - y);
            newX = x;
            newY = y;
            break;
          case 'top-right':
            newWidth = x - bbox.x;
            newHeight = bbox.height + (bbox.y - y);
            newY = y;
            break;
          case 'bottom-left':
            newWidth = bbox.width + (bbox.x - x);
            newHeight = y - bbox.y;
            newX = x;
            break;
          case 'bottom-right':
            newWidth = x - bbox.x;
            newHeight = y - bbox.y;
            break;
          case 'top-mid':
            newHeight = bbox.height + (bbox.y - y);
            newY = y;
            break;
          case 'bottom-mid':
            newHeight = y - bbox.y;
            break;
          case 'mid-left':
            newWidth = bbox.width + (bbox.x - x);
            newX = x;
            break;
          case 'mid-right':
            newWidth = x - bbox.x;
            break;
          default:
            break;
        }
        
        if(keepAspectRatio) {
          const aspectRatio = bbox.width / bbox.height;
          if(newWidth / newHeight > aspectRatio) {
            newWidth = newHeight * aspectRatio;
          } else {
            newHeight = newWidth / aspectRatio;
          }
          // Adjust x and y based on handle
          switch(this.selectedHandle) {
            case 'top-left':
              newX = bbox.x + bbox.width - newWidth;
              newY = bbox.y + bbox.height - newHeight;
              break;
            case 'top-right':
              newY = bbox.y + bbox.height - newHeight;
              break;
            case 'bottom-left':
              newX = bbox.x + bbox.width - newWidth;
              break;
            // Other handles can be adjusted similarly if needed
          }
        }
        
        // Update shape based on type
        if(['rectangle', 'road', 'corner'].includes(this.selectedShape.type)) {
          this.selectedShape.x = newX;
          this.selectedShape.y = newY;
          this.selectedShape.width = newWidth;
          this.selectedShape.height = newHeight;
        } else if(this.selectedShape.type === 'circle') {
          this.selectedShape.radius = Math.min(newWidth, newHeight) / 2;
        } else if(this.selectedShape.type === 'line') {
          if(['top-left', 'mid-left'].includes(this.selectedHandle)) {
            this.selectedShape.startX = newX;
            this.selectedShape.startY = newY;
          } else {
            this.selectedShape.endX = x;
            this.selectedShape.endY = y;
          }
        } else if(this.selectedShape.type === 'contour' || this.selectedShape.type === 'freeDraw' || this.selectedShape.type === 'eraser') {
          // Handle path-based shapes if needed
        }
        // Add more shape types if needed
      }
      
      rotateShape(x, y) {
        if(!this.selectedShape) return;
        
        const bbox = this.getBoundingBox(this.selectedShape);
        const centerX = bbox.x + bbox.width / 2;
        const centerY = bbox.y + bbox.height / 2;
        const radians = Math.atan2(y - centerY, x - centerX);
        this.selectedShape.rotation = radians;
      }
      
      moveShape(x, y) {
        if(!this.selectedShape) return;
        
        this.selectedShape.x = x - this.moveOffsetX;
        this.selectedShape.y = y - this.moveOffsetY;
      }
      
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid if enabled
        if(this.gridEnabled) {
          this.drawGrid();
        }
        
        this.shapes.forEach(shape => {
          this.drawShape(shape);
        });
        
        if(this.selectedShape && ['select', 'resize', 'rotate', 'move'].includes(this.currentTool)) {
          this.renderSelectionBox(this.selectedShape);
        }
      }
      
      drawGrid() {
        const gridSize = 50;
        this.ctx.save();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 0.5;
        
        for(let x = 0; x <= this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        
        for(let y = 0; y <= this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        
        this.ctx.restore();
      }
      
      drawShape(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const centerX = shape.type === 'circle' ? shape.x : shape.x + shape.width / 2;
          const centerY = shape.type === 'circle' ? shape.y : shape.y + shape.height / 2;
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        
        switch(shape.type) {
          case 'freeDraw':
          case 'contour':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i =1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.lineWidth = shape.lineWidth;
            if(shape.fillColor && shape.type === 'contour') {
              this.ctx.fillStyle = shape.fillColor;
              this.ctx.fill();
            }
            this.ctx.stroke();
            break;
          case 'rectangle':
            this.ctx.beginPath();
            this.ctx.rect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'circle':
            this.ctx.beginPath();
            this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'line':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'ruler':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.stroke();
            // Draw label
            const deltaX = shape.endX - shape.startX;
            const deltaY = shape.endY - shape.startY;
            const length = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY));
            const midX = (shape.startX + shape.endX) / 2;
            const midY = (shape.startY + shape.endY) / 2;
            this.ctx.fillStyle = '#FFD700';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${length} px`, midX, midY - 10);
            break;
          case 'road':
            this.ctx.save();
            this.ctx.translate(shape.x + shape.width / 2, shape.y + shape.height / 2);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-shape.x - shape.width / 2, -shape.y - shape.height / 2);
            this.ctx.fillStyle = '#555';
            this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            // Draw lane markings
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            const laneSpacing = shape.width / 4;
            for(let i = 1; i < 4; i++) {
              this.ctx.beginPath();
              this.ctx.moveTo(shape.x + laneSpacing * i, shape.y + shape.height / 4);
              this.ctx.lineTo(shape.x + laneSpacing * i, shape.y + (3 * shape.height) / 4);
              this.ctx.stroke();
            }
            this.ctx.restore();
            break;
          case 'corner':
            this.ctx.save();
            this.ctx.translate(shape.x + shape.width / 2, shape.y + shape.height / 2);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-shape.x - shape.width / 2, -shape.y - shape.height / 2);
            this.ctx.fillStyle = '#555';
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(shape.x + shape.radius, shape.y);
            this.ctx.lineTo(shape.x + shape.width - shape.radius, shape.y);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y, shape.x + shape.width, shape.y + shape.radius);
            this.ctx.lineTo(shape.x + shape.width, shape.y + shape.height - shape.radius);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y + shape.height, shape.x + shape.width - shape.radius, shape.y + shape.height);
            this.ctx.lineTo(shape.x + shape.radius, shape.y + shape.height);
            this.ctx.quadraticCurveTo(shape.x, shape.y + shape.height, shape.x, shape.y + shape.height - shape.radius);
            this.ctx.lineTo(shape.x, shape.y + shape.radius);
            this.ctx.quadraticCurveTo(shape.x, shape.y, shape.x + shape.radius, shape.y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.restore();
            break;
          case 'emoji':
            this.ctx.font = `${shape.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.emoji, shape.x, shape.y);
            break;
          case 'label':
            this.ctx.font = "16px Arial";
            this.ctx.fillStyle = shape.color || '#000';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.text, shape.x, shape.y);
            break;
          case 'eraser':
            // Eraser acts like freeDraw but clears
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i =1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = shape.lineWidth * 5; // Eraser is larger
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.stroke();
            this.ctx.globalCompositeOperation = 'source-over';
            break;
          default:
            break;
        }
        
        this.ctx.restore();
      }
      
      handleTooltip(e) {
        const { offsetX, offsetY } = e;
        let tooltipText = '';
        const shape = this.getShapeAtPosition(offsetX, offsetY);
        if(shape) {
          tooltipText = shape.type.charAt(0).toUpperCase() + shape.type.slice(1);
          this.showTooltip(tooltipText, e.clientX, e.clientY);
        } else {
          this.hideTooltip();
        }
      }
      
      showTooltip(text, x, y) {
        this.tooltip.textContent = text;
        this.tooltip.style.left = `${x + 10}px`;
        this.tooltip.style.top = `${y + 10}px`;
        this.tooltip.style.opacity = 1;
      }
      
      hideTooltip() {
        this.tooltip.style.opacity = 0;
      }
      
      showSparkles() {
        const sparkleCount = 20;
        for(let i = 0; i < sparkleCount; i++) {
          const sparkle = document.createElement('div');
          sparkle.classList.add('sparkle');
          sparkle.style.left = `${Math.random() * this.sparklesContainer.clientWidth}px`;
          sparkle.style.top = `${Math.random() * this.sparklesContainer.clientHeight}px`;
          sparkle.style.opacity = Math.random();
          this.sparklesContainer.appendChild(sparkle);
          sparkle.addEventListener('animationend', () => {
            sparkle.remove();
          });
        }
      }
      
      hideSparkles() {
        this.sparklesContainer.innerHTML = '';
      }
      
      restoreLastState() {
        if (this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].shapes;
          this.shapes = JSON.parse(JSON.stringify(lastState));
          this.render();
        }
      }
      
      saveState() {
        if (this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex + 1);
        }
        const shapesCopy = JSON.parse(JSON.stringify(this.shapes));
        this.history.push({ shapes: shapesCopy });
        this.historyIndex++;
        this.updateLayerList();
      }
      
      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.restoreLastState();
        }
      }
      
      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          this.restoreLastState();
        }
      }
      
      clearCanvas() {
        this.shapes = [];
        this.saveState();
        this.render();
      }
      
      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }
      
      // Layer Management
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';
        
        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.innerHTML = `<span>Layer ${index + 1}</span>`;
          
          const controls = document.createElement('div');
          controls.classList.add('layer-controls');
          
          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = '👁️';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => {
            this.historyIndex = index;
            this.restoreLastState();
          });
          
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '❌';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if (this.historyIndex >= this.history.length) {
              this.historyIndex = this.history.length - 1;
            }
            this.restoreLastState();
            this.updateLayerList();
          });
          
          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }
      
      // Emoji and Label Handling
      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedShape = {
          type: 'emoji',
          emoji: emoji,
          x: 0,
          y: 0,
          size: 24,
          rotation: 0
        };
      }
      
      addLabel() {
        const labelText = document.getElementById('labelInput').value.trim();
        if(labelText) {
          const label = {
            type: 'label',
            text: labelText,
            x: 50, // Default position
            y: 50,
            color: this.labelColor,
            rotation: 0
          };
          this.shapes.push(label);
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
        }
      }
    }
    
    window.addEventListener('load', () => {
      const drawingTool = new AdvancedDrawingTool('mainCanvas');
    });
  </script>
</body>
</html>
