<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Advanced Creative Canvas</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: Arial, sans-serif;
    }
    .sidebar {
      width: 250px;
      background-color: #2c3e50;
      color: #ecf0f1;
      padding: 15px;
      box-sizing: border-box;
      overflow-y: auto;
    }
    .sidebar h2 {
      text-align: center;
      margin-top: 0;
    }
    .tool-button {
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      background-color: #34495e;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }
    .tool-button.active {
      background-color: #1abc9c;
    }
    .tool-button:hover {
      background-color: #1abc9c;
    }
    .color-picker, .background-color-picker, .stroke-width-picker {
      margin: 10px 0;
    }
    .color-picker label, .background-color-picker label, .stroke-width-picker label {
      display: block;
      margin-bottom: 5px;
    }
    .label-input-container {
      margin: 10px 0;
    }
    .label-input-container label {
      display: block;
      margin-bottom: 5px;
    }
    .label-input-container input {
      width: 100%;
      padding: 5px;
      margin-bottom: 5px;
      box-sizing: border-box;
    }
    .label-input-container button {
      width: 100%;
      padding: 10px;
      background-color: #e74c3c;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    .label-input-container button:hover {
      background-color: #c0392b;
    }
    .emoji-picker {
      display: flex;
      flex-wrap: wrap;
      margin: 10px 0;
    }
    .emoji-btn {
      font-size: 24px;
      padding: 5px;
      margin: 3px;
      cursor: pointer;
      border: none;
      background: none;
    }
    .emoji-btn:hover {
      background-color: #34495e;
      border-radius: 4px;
    }
    .grid-toggle {
      margin: 10px 0;
    }
    .grid-toggle input {
      margin-right: 5px;
    }
    .action-buttons {
      margin: 10px 0;
    }
    .action-buttons button {
      width: 48%;
      padding: 10px;
      margin: 1%;
      background-color: #16a085;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 16px;
    }
    .action-buttons button:hover {
      background-color: #1abc9c;
    }
    .layer-list {
      margin-top: 20px;
    }
    .layer-list h3 {
      margin-bottom: 10px;
    }
    .layer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #34495e;
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
    }
    .layer-controls button {
      background: none;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      margin-left: 5px;
      font-size: 16px;
    }
    .layer-controls button:hover {
      color: #1abc9c;
    }
    .canvas-container {
      flex-grow: 1;
      position: relative;
      background-color: #ffffff;
    }
    #mainCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .tooltip {
      position: absolute;
      background-color: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      font-size: 14px;
    }
    .sparkles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 5;
    }
    .sparkle {
      position: absolute;
      width: 5px;
      height: 5px;
      background: yellow;
      border-radius: 50%;
      animation: sparkle 1s forwards;
    }
    @keyframes sparkle {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }
    /* Alignment Tools Styling */
    .alignment-tools {
      margin: 10px 0;
    }
    .alignment-tools button {
      width: 48%;
      padding: 10px;
      margin: 1%;
      background-color: #2980b9;
      border: none;
      color: #ecf0f1;
      cursor: pointer;
      font-size: 14px;
    }
    .alignment-tools button:hover {
      background-color: #3498db;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <h2>Tools</h2>
    <button id="freeDrawBtn" class="tool-button">✏️ Free Draw</button>
    <button id="contourBtn" class="tool-button">🖋️ Contour Maker</button>
    <button id="rectangleBtn" class="tool-button">▭ Rectangle</button>
    <button id="circleBtn" class="tool-button">⚪ Circle</button>
    <button id="lineBtn" class="tool-button">➖ Line</button>
    <button id="rulerBtn" class="tool-button">📏 Ruler</button>
    <button id="roadPenBtn" class="tool-button">🛣️ Road Pen</button>
    <button id="cornerPenBtn" class="tool-button">🔲 Corner Pen</button>
    <button id="moveBtn" class="tool-button">🚚 Move</button>
    <button id="selectBtn" class="tool-button">🔘 Select</button>
    <button id="resizeBtn" class="tool-button">↕️ Resize</button>
    <button id="rotateBtn" class="tool-button">🔄 Rotate</button>
    <!-- New Tools Added -->
    <button id="eraserBtn" class="tool-button">🧽 Eraser</button>
    <button id="textBtn" class="tool-button">🅰️ Text</button>
    
    <!-- Alignment Tools -->
    <div class="alignment-tools">
      <h3>Align Tools</h3>
      <button id="alignLeftBtn">⬅️ Align Left</button>
      <button id="alignCenterBtn">➡️ Align Center</button>
      <button id="alignRightBtn">⬆️ Align Right</button>
      <button id="alignTopBtn">🔼 Align Top</button>
      <button id="alignMiddleBtn">🔽 Align Middle</button>
      <button id="alignBottomBtn">🔻 Align Bottom</button>
    </div>
    
    <div class="color-picker">
      <label for="strokeColorPicker">Stroke Color:</label>
      <input type="color" id="strokeColorPicker" value="#000000">
    </div>
    <div class="color-picker">
      <label for="fillColorPicker">Fill Color:</label>
      <input type="color" id="fillColorPicker" value="#ffffff">
    </div>
    <div class="background-color-picker">
      <label for="backgroundColorPicker">Background Color:</label>
      <input type="color" id="backgroundColorPicker" value="#ffffff">
    </div>
    <div class="stroke-width-picker">
      <label for="strokeWidth">Stroke Width:</label>
      <input type="range" id="strokeWidth" min="1" max="10" value="2">
    </div>
    
    <div class="label-input-container">
      <label for="labelInput">Add Label:</label>
      <input type="text" id="labelInput" placeholder="Enter text">
      <label for="labelColorPicker">Label Color:</label>
      <input type="color" id="labelColorPicker" value="#000000">
      <button id="addLabelBtn">➕ Add Label</button>
      <div class="sparkles" id="sparklesContainer"></div>
    </div>
    
    <div class="emoji-picker">
      <!-- Updated Emojis to Construction and Road Signs -->
      <button class="emoji-btn" data-emoji="🚧">🚧</button>
      <button class="emoji-btn" data-emoji="🛣️">🛣️</button>
      <button class="emoji-btn" data-emoji="🅿️">🅿️</button>
      <button class="emoji-btn" data-emoji="🚦">🚦</button>
      <button class="emoji-btn" data-emoji="⛽">⛽</button>
      <button class="emoji-btn" data-emoji="🚸">🚸</button>
      <button class="emoji-btn" data-emoji="🚍">🚍</button>
      <button class="emoji-btn" data-emoji="🚗">🚗</button>
      <button class="emoji-btn" data-emoji="🛑">🛑</button>
      <button class="emoji-btn" data-emoji="🚨">🚨</button>
      <button class="emoji-btn" data-emoji="🚥">🚥</button>
      <button class="emoji-btn" data-emoji="🛤️">🛤️</button>
      <button class="emoji-btn" data-emoji="🚀">🚀</button>
      <button class="emoji-btn" data-emoji="🛩️">🛩️</button>
    </div>
    
    <div class="grid-toggle">
      <input type="checkbox" id="gridToggle">
      <label for="gridToggle">Toggle Grid</label>
    </div>
    
    <div class="action-buttons">
      <button id="undoBtn">↩️ Undo</button>
      <button id="redoBtn">↪️ Redo</button>
      <button id="clearBtn">🧹 Clear Canvas</button>
      <button id="exportBtn">📤 Export as PNG</button>
    </div>
    
    <div class="layer-list">
      <h3>Layers</h3>
      <div id="layerList">
        <!-- Layer items will be appended here -->
      </div>
    </div>
  </div>
  
  <div class="canvas-container">
    <canvas id="mainCanvas"></canvas>
    <div id="tooltip" class="tooltip"></div>
    <div class="sparkles" id="sparklesContainer"></div>
  </div>
  
  <script>
    // Helper functions
    function rotatePoint(point, center, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: center.x + (point.x - center.x) * cos - (point.y - center.y) * sin,
        y: center.y + (point.x - center.x) * sin + (point.y - center.y) * cos
      };
    }
    
    function getRotatedCorners(shape) {
      const center = { x: shape.x + shape.width / 2, y: shape.y + shape.height / 2 };
      return {
        topLeft: rotatePoint({ x: shape.x, y: shape.y }, center, shape.rotation),
        topRight: rotatePoint({ x: shape.x + shape.width, y: shape.y }, center, shape.rotation),
        bottomLeft: rotatePoint({ x: shape.x, y: shape.y + shape.height }, center, shape.rotation),
        bottomRight: rotatePoint({ x: shape.x + shape.width, y: shape.y + shape.height }, center, shape.rotation)
      };
    }
    
    class AdvancedDrawingTool {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.shapes = [];
        this.history = [];
        this.historyIndex = -1;
        this.currentTool = 'freeDraw';
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.currentShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.selectedShape = null;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.labelColor = '#000000';
        this.shiftPressed = false;
        this.tooltip = document.getElementById('tooltip');
        this.sparklesContainer = document.getElementById('sparklesContainer');
        this.gridEnabled = false;
        // For rotation/resizing of rotated shapes
        this.initialMouseAngle = 0;
        this.initialRotation = 0;
        this.resizeFixedCorner = null;
        this.resizeHandle = null;
        
        this.setupCanvas();
        this.saveState();
        this.initializeListeners();
      }
      
      setupCanvas() {
        this.resizeCanvas();
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        this.ctx.strokeStyle = document.getElementById('strokeColorPicker').value;
        this.ctx.fillStyle = document.getElementById('fillColorPicker').value;
        this.ctx.lineWidth = document.getElementById('strokeWidth').value;
        this.canvas.style.backgroundColor = document.getElementById('backgroundColorPicker').value;
      }
      
      initializeListeners() {
        // Tool Buttons
        document.getElementById('freeDrawBtn').addEventListener('click', () => this.setTool('freeDraw'));
        document.getElementById('contourBtn').addEventListener('click', () => this.setTool('contour'));
        document.getElementById('rectangleBtn').addEventListener('click', () => this.setTool('rectangle'));
        document.getElementById('circleBtn').addEventListener('click', () => this.setTool('circle'));
        document.getElementById('lineBtn').addEventListener('click', () => this.setTool('line'));
        document.getElementById('rulerBtn').addEventListener('click', () => this.setTool('ruler'));
        document.getElementById('roadPenBtn').addEventListener('click', () => this.setTool('roadPen'));
        document.getElementById('cornerPenBtn').addEventListener('click', () => this.setTool('cornerPen'));
        document.getElementById('moveBtn').addEventListener('click', () => this.setTool('move'));
        document.getElementById('selectBtn').addEventListener('click', () => this.setTool('select'));
        document.getElementById('resizeBtn').addEventListener('click', () => this.setTool('resize'));
        document.getElementById('rotateBtn').addEventListener('click', () => this.setTool('rotate'));
        document.getElementById('eraserBtn').addEventListener('click', () => this.setTool('eraser'));
        document.getElementById('textBtn').addEventListener('click', () => this.setTool('text'));
        
        // Alignment Tools
        document.getElementById('alignLeftBtn').addEventListener('click', () => this.alignShape('left'));
        document.getElementById('alignCenterBtn').addEventListener('click', () => this.alignShape('center'));
        document.getElementById('alignRightBtn').addEventListener('click', () => this.alignShape('right'));
        document.getElementById('alignTopBtn').addEventListener('click', () => this.alignShape('top'));
        document.getElementById('alignMiddleBtn').addEventListener('click', () => this.alignShape('middle'));
        document.getElementById('alignBottomBtn').addEventListener('click', () => this.alignShape('bottom'));
        
        // Color and Stroke
        document.getElementById('strokeColorPicker').addEventListener('change', (e) => {
          this.ctx.strokeStyle = e.target.value;
          if(this.selectedShape) { this.selectedShape.strokeColor = e.target.value; this.saveState(); this.render(); }
        });
        document.getElementById('fillColorPicker').addEventListener('change', (e) => {
          this.ctx.fillStyle = e.target.value;
          if(this.selectedShape && ['rectangle', 'circle', 'contour'].includes(this.selectedShape.type)) {
            this.selectedShape.fillColor = e.target.value; this.saveState(); this.render();
          }
        });
        document.getElementById('backgroundColorPicker').addEventListener('change', (e) => {
          this.canvas.style.backgroundColor = e.target.value; this.saveState(); this.render();
        });
        document.getElementById('strokeWidth').addEventListener('input', (e) => {
          this.ctx.lineWidth = e.target.value;
          if(this.selectedShape) { this.selectedShape.lineWidth = e.target.value; this.saveState(); this.render(); }
        });
        
        // Emoji Picker
        document.querySelector('.emoji-picker').addEventListener('click', (e) => {
          if(e.target.classList.contains('emoji-btn')) { this.selectEmoji(e.target.getAttribute('data-emoji')); }
        });
        
        // Label Handling
        document.getElementById('addLabelBtn').addEventListener('click', () => this.addLabel());
        document.getElementById('labelColorPicker').addEventListener('change', (e) => { this.labelColor = e.target.value; });
        
        // Canvas Mouse Events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseout', (e) => this.onMouseUp(e));
        
        // Action Buttons
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportCanvas());
        
        // Grid Toggle
        document.getElementById('gridToggle').addEventListener('change', (e) => { this.gridEnabled = e.target.checked; this.render(); });
        
        // Window Resize
        window.addEventListener('resize', () => this.resizeCanvas());
        
        // Keyboard for Shift
        window.addEventListener('keydown', (e) => { if(e.key === 'Shift') this.shiftPressed = true; });
        window.addEventListener('keyup', (e) => { if(e.key === 'Shift') this.shiftPressed = false; });
        
        // Tooltip Handling
        this.canvas.addEventListener('mousemove', (e) => this.handleTooltip(e));
        this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
        
        // Sparkles for label input
        document.getElementById('labelInput').addEventListener('input', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('focus', () => this.showSparkles());
        document.getElementById('labelInput').addEventListener('blur', () => this.hideSparkles());
      }
      
      resizeCanvas() {
        const parentWidth = this.canvas.parentElement.clientWidth;
        const parentHeight = this.canvas.parentElement.clientHeight;
        if(parentWidth === 0 || parentHeight === 0) return;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.drawImage(this.canvas, 0, 0);
        this.canvas.width = parentWidth;
        this.canvas.height = parentHeight;
        this.ctx.drawImage(tempCanvas, 0, 0);
        this.render();
      }
      
      setTool(tool) {
        this.currentTool = tool;
        this.selectedShape = null;
        this.moveOffsetX = 0;
        this.moveOffsetY = 0;
        this.isMoving = false;
        this.isResizing = false;
        this.isRotating = false;
        this.resizeHandle = null;
        this.resizeFixedCorner = null;
        document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`${tool}Btn`)?.classList.add('active');
        this.render();
        console.log(`Tool set to: ${tool}`);
      }
      
      alignShape(alignment) {
        if(!this.selectedShape) { alert('Please select a shape to align.'); return; }
        const canvasWidth = this.canvas.width;
        const canvasHeight = this.canvas.height;
        const bbox = this.getBoundingBox(this.selectedShape);
        switch(alignment) {
          case 'left': this.selectedShape.x = 0; break;
          case 'center': this.selectedShape.x = (canvasWidth - bbox.width)/2; break;
          case 'right': this.selectedShape.x = canvasWidth - bbox.width; break;
          case 'top': this.selectedShape.y = 0; break;
          case 'middle': this.selectedShape.y = (canvasHeight - bbox.height)/2; break;
          case 'bottom': this.selectedShape.y = canvasHeight - bbox.height; break;
        }
        this.saveState();
        this.render();
      }
      
      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedShape = { type: 'emoji', emoji: emoji, x: 0, y: 0, size: 24, rotation: 0 };
      }
      
      addLabel() {
        const labelText = document.getElementById('labelInput').value.trim();
        if(labelText) {
          const label = { type: 'label', text: labelText, x: 50, y: 50, color: this.labelColor, rotation: 0 };
          this.shapes.push(label);
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
        }
      }
      
      onMouseDown(e) {
        const { offsetX, offsetY } = e;
        // For resize/rotate, auto-select shape if not already selected
        if((this.currentTool === 'resize' || this.currentTool === 'rotate') && !this.selectedShape) {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.render(); }
        }
        // Check if a handle is clicked when in resize/rotate mode
        if(this.selectedShape && (this.currentTool === 'resize' || this.currentTool === 'rotate')) {
          let handle = this.getHandleAtPosition(offsetX, offsetY, this.selectedShape);
          if(handle) {
            if(handle === 'rotate') {
              this.isRotating = true;
              const center = { x: this.selectedShape.x + this.selectedShape.width/2, y: this.selectedShape.y + this.selectedShape.height/2 };
              this.initialMouseAngle = Math.atan2(offsetY - center.y, offsetX - center.x);
              this.initialRotation = this.selectedShape.rotation;
            } else {
              this.isResizing = true;
              this.resizeHandle = handle;
              if(this.selectedShape.rotation) {
                const corners = getRotatedCorners(this.selectedShape);
                switch(handle) {
                  case 'top-left': this.resizeFixedCorner = corners.bottomRight; break;
                  case 'top-right': this.resizeFixedCorner = corners.bottomLeft; break;
                  case 'bottom-left': this.resizeFixedCorner = corners.topRight; break;
                  case 'bottom-right': this.resizeFixedCorner = corners.topLeft; break;
                  case 'top-mid': this.resizeFixedCorner = {
                    x: (corners.bottomLeft.x + corners.bottomRight.x) / 2,
                    y: (corners.bottomLeft.y + corners.bottomRight.y) / 2
                  }; break;
                  case 'bottom-mid': this.resizeFixedCorner = {
                    x: (corners.topLeft.x + corners.topRight.x) / 2,
                    y: (corners.topLeft.y + corners.topRight.y) / 2
                  }; break;
                  case 'mid-left': this.resizeFixedCorner = {
                    x: (corners.topRight.x + corners.bottomRight.x) / 2,
                    y: (corners.topRight.y + corners.bottomRight.y) / 2
                  }; break;
                  case 'mid-right': this.resizeFixedCorner = {
                    x: (corners.topLeft.x + corners.bottomLeft.x) / 2,
                    y: (corners.topLeft.y + corners.bottomLeft.y) / 2
                  }; break;
                }
              }
            }
            return;
          }
        }
        // Move and Select
        if(this.currentTool === 'move') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.isMoving = true; this.moveOffsetX = offsetX - shape.x; this.moveOffsetY = offsetY - shape.y; this.render(); return; }
        }
        if(this.currentTool === 'select') {
          const shape = this.getShapeAtPosition(offsetX, offsetY);
          if(shape) { this.selectedShape = shape; this.render(); return; }
          else { this.selectedShape = null; this.render(); }
        }
        // Drawing tools
        if(['freeDraw', 'contour', 'rectangle', 'circle', 'line', 'ruler', 'roadPen', 'cornerPen', 'emoji', 'eraser', 'text'].includes(this.currentTool)) {
          this.isDrawing = true;
          this.startX = offsetX;
          this.startY = offsetY;
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape = { type: this.currentTool, path: [{x: offsetX, y: offsetY}], strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'rectangle') {
            this.currentShape = { type: 'rectangle', x: offsetX, y: offsetY, width: 0, height: 0, strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'circle') {
            this.currentShape = { type: 'circle', x: offsetX, y: offsetY, radius: 0, strokeColor: document.getElementById('strokeColorPicker').value, fillColor: document.getElementById('fillColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'line') {
            this.currentShape = { type: 'line', startX: offsetX, startY: offsetY, endX: offsetX, endY: offsetY, strokeColor: document.getElementById('strokeColorPicker').value, lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'ruler') {
            this.currentShape = { type: 'ruler', startX: offsetX, startY: offsetY, endX: offsetX, endY: offsetY, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'roadPen') {
            this.currentShape = { type: 'road', x: offsetX, y: offsetY, width: 200, height: 20, rotation: 0 };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; this.saveState(); this.render();
          } else if(this.currentTool === 'cornerPen') {
            this.currentShape = { type: 'corner', x: offsetX, y: offsetY, width: 50, height: 50, radius: 25, rotation: 0 };
            this.shapes.push(this.currentShape);
            this.isDrawing = false; this.saveState(); this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape = { type: 'eraser', path: [{x: offsetX, y: offsetY}], lineWidth: document.getElementById('strokeWidth').value, rotation: 0 };
            this.shapes.push(this.currentShape);
          } else if(this.currentTool === 'text') {
            const text = prompt("Enter text:");
            if(text) {
              const textColor = document.getElementById('labelColorPicker').value;
              const newText = { type: 'label', text: text, x: offsetX, y: offsetY, color: textColor, rotation: 0 };
              this.shapes.push(newText);
              this.saveState();
              this.render();
            }
            this.isDrawing = false;
          }
        }
      }
      
      onMouseMove(e) {
        const { offsetX, offsetY } = e;
        this.handleTooltip(e);
        // Change cursor when hovering over handles in resize/rotate mode
        if(this.selectedShape && (this.currentTool === 'resize' || this.currentTool === 'rotate')) {
          const handle = this.getHandleAtPosition(offsetX, offsetY, this.selectedShape);
          if(handle) {
            this.canvas.style.cursor = (handle === 'rotate') ? 'grab' : 'nwse-resize';
          } else {
            this.canvas.style.cursor = 'default';
          }
        }
        if(this.isDrawing && this.currentShape) {
          if(this.currentTool === 'freeDraw' || this.currentTool === 'contour') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          } else if(this.currentTool === 'rectangle') {
            this.currentShape.width = offsetX - this.startX;
            this.currentShape.height = offsetY - this.startY;
            this.render();
          } else if(this.currentTool === 'circle') {
            const radius = Math.sqrt(Math.pow(offsetX - this.startX,2) + Math.pow(offsetY - this.startY,2));
            this.currentShape.radius = radius;
            this.render();
          } else if(this.currentTool === 'line' || this.currentTool === 'ruler') {
            this.currentShape.endX = offsetX;
            this.currentShape.endY = offsetY;
            this.render();
          } else if(this.currentTool === 'eraser') {
            this.currentShape.path.push({x: offsetX, y: offsetY});
            this.render();
          }
        }
        if(this.isMoving && this.selectedShape) {
          this.selectedShape.x = offsetX - this.moveOffsetX;
          this.selectedShape.y = offsetY - this.moveOffsetY;
          this.render();
        }
        if(this.isRotating && this.selectedShape) {
          const center = { x: this.selectedShape.x + this.selectedShape.width/2, y: this.selectedShape.y + this.selectedShape.height/2 };
          const currentAngle = Math.atan2(offsetY - center.y, offsetX - center.x);
          this.selectedShape.rotation = this.initialRotation + (currentAngle - this.initialMouseAngle);
          this.render();
        }
        if(this.isResizing && this.selectedShape && this.resizeHandle) {
          if(this.selectedShape.rotation) {
            const centerNew = { x: (this.resizeFixedCorner.x + offsetX)/2, y: (this.resizeFixedCorner.y + offsetY)/2 };
            const cos = Math.cos(-this.selectedShape.rotation);
            const sin = Math.sin(-this.selectedShape.rotation);
            const localFixed = { x: cos * (this.resizeFixedCorner.x - centerNew.x) - sin * (this.resizeFixedCorner.y - centerNew.y),
                                 y: sin * (this.resizeFixedCorner.x - centerNew.x) + cos * (this.resizeFixedCorner.y - centerNew.y) };
            const localCurrent = { x: cos * (offsetX - centerNew.x) - sin * (offsetY - centerNew.y),
                                   y: sin * (offsetX - centerNew.x) + cos * (offsetY - centerNew.y) };
            const newWidth = Math.abs(localCurrent.x - localFixed.x);
            const newHeight = Math.abs(localCurrent.y - localFixed.y);
            const newCenterLocal = { x: (localFixed.x + localCurrent.x)/2, y: (localFixed.y + localCurrent.y)/2 };
            const newCenterCanvas = {
              x: centerNew.x + newCenterLocal.x * Math.cos(this.selectedShape.rotation) - newCenterLocal.y * Math.sin(this.selectedShape.rotation),
              y: centerNew.y + newCenterLocal.x * Math.sin(this.selectedShape.rotation) + newCenterLocal.y * Math.cos(this.selectedShape.rotation)
            };
            this.selectedShape.width = newWidth;
            this.selectedShape.height = newHeight;
            this.selectedShape.x = newCenterCanvas.x - newWidth/2;
            this.selectedShape.y = newCenterCanvas.y - newHeight/2;
          } else {
            const bbox = this.getBoundingBox(this.selectedShape);
            let newWidth = bbox.width, newHeight = bbox.height, newX = bbox.x, newY = bbox.y;
            switch(this.resizeHandle) {
              case 'top-left': newWidth = bbox.width + (bbox.x - offsetX); newHeight = bbox.height + (bbox.y - offsetY); newX = offsetX; newY = offsetY; break;
              case 'top-right': newWidth = offsetX - bbox.x; newHeight = bbox.height + (bbox.y - offsetY); newY = offsetY; break;
              case 'bottom-left': newWidth = bbox.width + (bbox.x - offsetX); newHeight = offsetY - bbox.y; newX = offsetX; break;
              case 'bottom-right': newWidth = offsetX - bbox.x; newHeight = offsetY - bbox.y; break;
              case 'top-mid': newHeight = bbox.height + (bbox.y - offsetY); newY = offsetY; break;
              case 'bottom-mid': newHeight = offsetY - bbox.y; break;
              case 'mid-left': newWidth = bbox.width + (bbox.x - offsetX); newX = offsetX; break;
              case 'mid-right': newWidth = offsetX - bbox.x; break;
            }
            if(this.shiftPressed) {
              const aspectRatio = bbox.width / bbox.height;
              if(newWidth / newHeight > aspectRatio) { newWidth = newHeight * aspectRatio; }
              else { newHeight = newWidth / aspectRatio; }
            }
            this.selectedShape.x = newX;
            this.selectedShape.y = newY;
            this.selectedShape.width = newWidth;
            this.selectedShape.height = newHeight;
          }
          this.render();
        }
      }
      
      onMouseUp(e) {
        if(this.isDrawing) { this.isDrawing = false; this.currentShape = null; this.saveState(); }
        if(this.isMoving) { this.isMoving = false; this.saveState(); }
        if(this.isResizing) { this.isResizing = false; this.resizeHandle = null; this.resizeFixedCorner = null; this.saveState(); }
        if(this.isRotating) { this.isRotating = false; this.saveState(); }
        if(this.currentTool === 'emoji' && this.selectedShape) {
          this.selectedShape.x = e.offsetX;
          this.selectedShape.y = e.offsetY;
          this.shapes.push({...this.selectedShape});
          this.selectedShape = null;
          this.saveState();
          this.render();
          this.setTool('freeDraw');
        }
      }
      
      getBoundingBox(shape) {
        if(shape.type === 'circle') {
          return { x: shape.x - shape.radius, y: shape.y - shape.radius, width: shape.radius*2, height: shape.radius*2 };
        } else if(['rectangle', 'road', 'corner', 'label', 'emoji', 'line', 'ruler', 'freeDraw', 'contour', 'eraser'].includes(shape.type)) {
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            return { x: shape.x - emojiWidth/2, y: shape.y - shape.size, width: emojiWidth, height: shape.size };
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            return { x: shape.x, y: shape.y, width: textWidth, height: 16 };
          } else if(shape.type === 'line' || shape.type === 'ruler') {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return { x: minX, y: minY, width: maxX-minX, height: maxY-minY };
          } else if(shape.type === 'eraser') {
            const xs = shape.path.map(p => p.x), ys = shape.path.map(p => p.y);
            return { x: Math.min(...xs)-shape.lineWidth, y: Math.min(...ys)-shape.lineWidth, width: Math.max(...xs)-Math.min(...xs)+shape.lineWidth*2, height: Math.max(...ys)-Math.min(...ys)+shape.lineWidth*2 };
          } else {
            if(shape.rotation) {
              const corners = getRotatedCorners(shape);
              const xs = [corners.topLeft.x, corners.topRight.x, corners.bottomLeft.x, corners.bottomRight.x];
              const ys = [corners.topLeft.y, corners.topRight.y, corners.bottomLeft.y, corners.bottomRight.y];
              return { x: Math.min(...xs), y: Math.min(...ys), width: Math.max(...xs)-Math.min(...xs), height: Math.max(...ys)-Math.min(...ys) };
            } else {
              return { x: shape.x, y: shape.y, width: shape.width, height: shape.height };
            }
          }
        }
        return { x:0, y:0, width:0, height:0 };
      }
      
      renderSelectionBox(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const corners = getRotatedCorners(shape);
          this.ctx.beginPath();
          this.ctx.moveTo(corners.topLeft.x, corners.topLeft.y);
          this.ctx.lineTo(corners.topRight.x, corners.topRight.y);
          this.ctx.lineTo(corners.bottomRight.x, corners.bottomRight.y);
          this.ctx.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
          this.ctx.closePath();
          this.ctx.strokeStyle = '#1abc9c';
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5, 3]);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          const handles = [
            { position: 'top-left', x: corners.topLeft.x, y: corners.topLeft.y },
            { position: 'top-right', x: corners.topRight.x, y: corners.topRight.y },
            { position: 'bottom-left', x: corners.bottomLeft.x, y: corners.bottomLeft.y },
            { position: 'bottom-right', x: corners.bottomRight.x, y: corners.bottomRight.y },
            { position: 'top-mid', x: (corners.topLeft.x+corners.topRight.x)/2, y: (corners.topLeft.y+corners.topRight.y)/2 },
            { position: 'bottom-mid', x: (corners.bottomLeft.x+corners.bottomRight.x)/2, y: (corners.bottomLeft.y+corners.bottomRight.y)/2 },
            { position: 'mid-left', x: (corners.topLeft.x+corners.bottomLeft.x)/2, y: (corners.topLeft.y+corners.bottomLeft.y)/2 },
            { position: 'mid-right', x: (corners.topRight.x+corners.bottomRight.x)/2, y: (corners.topRight.y+corners.bottomRight.y)/2 }
          ];
          handles.forEach(handle => {
            this.ctx.fillStyle = '#1abc9c';
            this.ctx.fillRect(handle.x - 4, handle.y - 4, 8, 8);
          });
          const rotateHandle = { x: (handles.find(h => h.position==='top-mid').x), y: (handles.find(h => h.position==='top-mid').y - 30) };
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(rotateHandle.x - 4, rotateHandle.y - 4, 8, 8);
        } else {
          const bbox = this.getBoundingBox(shape);
          this.ctx.strokeStyle = '#1abc9c';
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5,3]);
          this.ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
          this.ctx.setLineDash([]);
          const handles = this.getHandles(bbox);
          handles.forEach(handle => {
            this.ctx.fillStyle = '#1abc9c';
            this.ctx.fillRect(handle.x, handle.y, handle.width, handle.height);
          });
          const rotateHandle = { x: bbox.x + bbox.width/2 - 4, y: bbox.y - 30 - 4, width: 8, height: 8 };
          this.ctx.fillStyle = '#1abc9c';
          this.ctx.fillRect(rotateHandle.x, rotateHandle.y, rotateHandle.width, rotateHandle.height);
        }
        this.ctx.restore();
      }
      
      getHandles(bbox) {
        const size = 8;
        return [
          { x: bbox.x - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-right' },
          { x: bbox.x - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-right' },
          { x: bbox.x + bbox.width/2 - size/2, y: bbox.y - size/2, width: size, height: size, position: 'top-mid' },
          { x: bbox.x + bbox.width/2 - size/2, y: bbox.y + bbox.height - size/2, width: size, height: size, position: 'bottom-mid' },
          { x: bbox.x - size/2, y: bbox.y + bbox.height/2 - size/2, width: size, height: size, position: 'mid-left' },
          { x: bbox.x + bbox.width - size/2, y: bbox.y + bbox.height/2 - size/2, width: size, height: size, position: 'mid-right' }
        ];
      }
      
      // Increased tolerance for handle detection (8px)
      getHandleAtPosition(x, y, shape) {
        if(shape.rotation) {
          const corners = getRotatedCorners(shape);
          const handles = [
            { position: 'top-left', x: corners.topLeft.x, y: corners.topLeft.y },
            { position: 'top-right', x: corners.topRight.x, y: corners.topRight.y },
            { position: 'bottom-left', x: corners.bottomLeft.x, y: corners.bottomLeft.y },
            { position: 'bottom-right', x: corners.bottomRight.x, y: corners.bottomRight.y },
            { position: 'top-mid', x: (corners.topLeft.x+corners.topRight.x)/2, y: (corners.topLeft.y+corners.topRight.y)/2 },
            { position: 'bottom-mid', x: (corners.bottomLeft.x+corners.bottomRight.x)/2, y: (corners.bottomLeft.y+corners.bottomRight.y)/2 },
            { position: 'mid-left', x: (corners.topLeft.x+corners.bottomLeft.x)/2, y: (corners.topLeft.y+corners.bottomLeft.y)/2 },
            { position: 'mid-right', x: (corners.topRight.x+corners.bottomRight.x)/2, y: (corners.topRight.y+corners.bottomRight.y)/2 }
          ];
          const topMid = handles.find(h => h.position==='top-mid');
          handles.push({ position: 'rotate', x: topMid.x, y: topMid.y - 30 });
          for(let handle of handles) {
            if(x >= handle.x - 8 && x <= handle.x + 8 && y >= handle.y - 8 && y <= handle.y + 8) {
              return handle.position;
            }
          }
          return null;
        } else {
          const bbox = this.getBoundingBox(shape);
          const handles = this.getHandles(bbox);
          const rotateHandle = { x: bbox.x + bbox.width/2 - 4, y: bbox.y - 30 - 4, width: 8, height: 8, position: 'rotate' };
          handles.push(rotateHandle);
          for(let handle of handles) {
            if(x >= handle.x && x <= handle.x + handle.width && y >= handle.y && y <= handle.y + handle.height) {
              return handle.position;
            }
          }
          return null;
        }
      }
      
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if(this.gridEnabled) this.drawGrid();
        this.shapes.forEach(shape => this.drawShape(shape));
        if(this.selectedShape && ['select', 'resize', 'rotate', 'move'].includes(this.currentTool)) {
          this.renderSelectionBox(this.selectedShape);
        }
      }
      
      drawGrid() {
        const gridSize = 50;
        this.ctx.save();
        this.ctx.strokeStyle = '#bdc3c7';
        this.ctx.lineWidth = 0.5;
        for(let x = 0; x <= this.canvas.width; x += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, this.canvas.height);
          this.ctx.stroke();
        }
        for(let y = 0; y <= this.canvas.height; y += gridSize) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y);
          this.ctx.lineTo(this.canvas.width, y);
          this.ctx.stroke();
        }
        this.ctx.restore();
      }
      
      drawShape(shape) {
        this.ctx.save();
        if(shape.rotation) {
          const centerX = shape.x + shape.width/2;
          const centerY = shape.y + shape.height/2;
          this.ctx.translate(centerX, centerY);
          this.ctx.rotate(shape.rotation);
          this.ctx.translate(-centerX, -centerY);
        }
        switch(shape.type) {
          case 'freeDraw':
          case 'contour':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i = 1; i < shape.path.length; i++) {
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.lineWidth = shape.lineWidth;
            if(shape.fillColor && shape.type === 'contour') { this.ctx.fillStyle = shape.fillColor; this.ctx.fill(); }
            this.ctx.stroke();
            break;
          case 'rectangle':
            this.ctx.beginPath();
            this.ctx.rect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'circle':
            this.ctx.beginPath();
            this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI*2);
            this.ctx.fillStyle = shape.fillColor;
            this.ctx.fill();
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'line':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = shape.lineWidth;
            this.ctx.strokeStyle = shape.strokeColor;
            this.ctx.stroke();
            break;
          case 'ruler':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.startX, shape.startY);
            this.ctx.lineTo(shape.endX, shape.endY);
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = '#FFD700';
            this.ctx.stroke();
            const deltaX = shape.endX - shape.startX, deltaY = shape.endY - shape.startY;
            const length = Math.round(Math.sqrt(deltaX*deltaX + deltaY*deltaY));
            const midX = (shape.startX + shape.endX)/2, midY = (shape.startY + shape.endY)/2;
            this.ctx.fillStyle = '#FFD700';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(`${length} px`, midX, midY - 10);
            break;
          case 'road':
            this.ctx.save();
            const cx = shape.x + shape.width/2, cy = shape.y + shape.height/2;
            this.ctx.translate(cx, cy);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-cx, -cy);
            this.ctx.fillStyle = '#555';
            this.ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 2;
            const laneSpacing = shape.width/4;
            for(let i = 1; i < 4; i++){
              this.ctx.beginPath();
              this.ctx.moveTo(shape.x + laneSpacing*i, shape.y + shape.height/4);
              this.ctx.lineTo(shape.x + laneSpacing*i, shape.y + (3*shape.height)/4);
              this.ctx.stroke();
            }
            this.ctx.restore();
            break;
          case 'corner':
            this.ctx.save();
            const ccx = shape.x + shape.width/2, ccy = shape.y + shape.height/2;
            this.ctx.translate(ccx, ccy);
            this.ctx.rotate(shape.rotation);
            this.ctx.translate(-ccx, -ccy);
            this.ctx.fillStyle = '#555';
            this.ctx.strokeStyle = '#333';
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(shape.x + shape.radius, shape.y);
            this.ctx.lineTo(shape.x + shape.width - shape.radius, shape.y);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y, shape.x + shape.width, shape.y + shape.radius);
            this.ctx.lineTo(shape.x + shape.width, shape.y + shape.height - shape.radius);
            this.ctx.quadraticCurveTo(shape.x + shape.width, shape.y + shape.height, shape.x + shape.width - shape.radius, shape.y + shape.height);
            this.ctx.lineTo(shape.x + shape.radius, shape.y + shape.height);
            this.ctx.quadraticCurveTo(shape.x, shape.y + shape.height, shape.x, shape.y + shape.height - shape.radius);
            this.ctx.lineTo(shape.x, shape.y + shape.radius);
            this.ctx.quadraticCurveTo(shape.x, shape.y, shape.x + shape.radius, shape.y);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.restore();
            break;
          case 'emoji':
            this.ctx.font = `${shape.size}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.emoji, shape.x, shape.y);
            break;
          case 'label':
            this.ctx.font = "16px Arial";
            this.ctx.fillStyle = shape.color || '#000';
            this.ctx.textAlign = 'left';
            this.ctx.textBaseline = 'top';
            this.ctx.fillText(shape.text, shape.x, shape.y);
            break;
          case 'eraser':
            this.ctx.beginPath();
            this.ctx.moveTo(shape.path[0].x, shape.path[0].y);
            for(let i = 1; i < shape.path.length; i++){
              this.ctx.lineTo(shape.path[i].x, shape.path[i].y);
            }
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = shape.lineWidth * 5;
            this.ctx.globalCompositeOperation = 'destination-out';
            this.ctx.stroke();
            this.ctx.globalCompositeOperation = 'source-over';
            break;
          default:
            break;
        }
        this.ctx.restore();
      }
      
      handleTooltip(e) {
        const { offsetX, offsetY } = e;
        const shape = this.getShapeAtPosition(offsetX, offsetY);
        if(shape) {
          this.showTooltip(shape.type.charAt(0).toUpperCase() + shape.type.slice(1), e.clientX, e.clientY);
        } else {
          this.hideTooltip();
        }
      }
      
      showTooltip(text, x, y) {
        this.tooltip.textContent = text;
        this.tooltip.style.left = `${x + 10}px`;
        this.tooltip.style.top = `${y + 10}px`;
        this.tooltip.style.opacity = 1;
      }
      
      hideTooltip() { this.tooltip.style.opacity = 0; }
      
      showSparkles() {
        const sparkleCount = 20;
        for(let i = 0; i < sparkleCount; i++){
          const sparkle = document.createElement('div');
          sparkle.classList.add('sparkle');
          sparkle.style.left = `${Math.random()*this.sparklesContainer.clientWidth}px`;
          sparkle.style.top = `${Math.random()*this.sparklesContainer.clientHeight}px`;
          sparkle.style.opacity = Math.random();
          this.sparklesContainer.appendChild(sparkle);
          sparkle.addEventListener('animationend', () => sparkle.remove());
        }
      }
      
      hideSparkles() { this.sparklesContainer.innerHTML = ''; }
      
      restoreLastState() {
        if(this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].shapes;
          this.shapes = JSON.parse(JSON.stringify(lastState));
          this.render();
        }
      }
      
      saveState() {
        if(this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex+1);
        }
        const shapesCopy = JSON.parse(JSON.stringify(this.shapes));
        this.history.push({ shapes: shapesCopy });
        this.historyIndex++;
        this.updateLayerList();
      }
      
      undo() { if(this.historyIndex > 0) { this.historyIndex--; this.restoreLastState(); } }
      
      redo() { if(this.historyIndex < this.history.length - 1) { this.historyIndex++; this.restoreLastState(); } }
      
      clearCanvas() { this.shapes = []; this.saveState(); this.render(); }
      
      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }
      
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';
        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.innerHTML = `<span>Layer ${index+1}</span>`;
          const controls = document.createElement('div');
          controls.classList.add('layer-controls');
          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = '👁️';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => { this.historyIndex = index; this.restoreLastState(); });
          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '❌';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if(this.historyIndex >= this.history.length) { this.historyIndex = this.history.length - 1; }
            this.restoreLastState();
            this.updateLayerList();
          });
          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }
      
      getShapeAtPosition(x, y) {
        for(let i = this.shapes.length - 1; i >= 0; i--){
          const shape = this.shapes[i];
          if(shape.type === 'emoji') {
            const emojiWidth = this.ctx.measureText(shape.emoji).width;
            if(x >= shape.x - emojiWidth/2 && x <= shape.x + emojiWidth/2 &&
               y >= shape.y - shape.size && y <= shape.y) return shape;
          } else if(shape.type === 'label') {
            this.ctx.font = "16px Arial";
            const textWidth = this.ctx.measureText(shape.text).width;
            if(x >= shape.x && x <= shape.x + textWidth &&
               y >= shape.y && y <= shape.y + 16) return shape;
          } else if(shape.type === 'ruler') {
            const dist = this.pointToLineDistance(x, y, shape.startX, shape.startY, shape.endX, shape.endY);
            if(dist <= 5) return shape;
          } else if(shape.type === 'road' || shape.type === 'corner') {
            if(x >= shape.x && x <= shape.x+shape.width &&
               y >= shape.y && y <= shape.y+shape.height) return shape;
          } else if(['freeDraw','contour','rectangle','circle','line','eraser'].includes(shape.type)) {
            const bbox = this.getBoundingBox(shape);
            if(x >= bbox.x && x <= bbox.x+bbox.width && y >= bbox.y && y <= bbox.y+bbox.height) return shape;
          }
        }
        return null;
      }
      
      pointToLineDistance(px, py, x1, y1, x2, y2) {
        const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
        const dot = A * C + B * D, lenSq = C * C + D * D;
        let param = (lenSq !== 0) ? dot / lenSq : -1;
        let xx, yy;
        if(param < 0) { xx = x1; yy = y1; }
        else if(param > 1) { xx = x2; yy = y2; }
        else { xx = x1 + param * C; yy = y1 + param * D; }
        return Math.sqrt((px - xx)**2 + (py - yy)**2);
      }
    }
    
    // DALL·E prompt (as comment): "A futuristic digital canvas interface with interactive draggable rotate and resize handles, neon UI elements, and a creative workspace background."
    console.log("Advanced Creative Canvas loaded. Ready to draw, resize, and rotate!");
    
    window.addEventListener('load', () => { new AdvancedDrawingTool('mainCanvas'); });
  </script>
</body>
</html>
